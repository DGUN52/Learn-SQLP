2.1 인덱스 구조 및 탐색
- 인덱스 탐색과정은 수직적 탐색과 수평적 탐색 단 두가지 단계로 이루어진다.

  2.1.1 미리 보는 인덱스 튜닝
    - 데이터를 찾는 두가지 방법 -> 테이블 전체 스캔, 인덱스이용
    - 인덱스 : 큰 테이블에서 소량의 데이터를 검색할 때 사용 -> OLTP애서 특히 중요
    - 인덱스 튜닝의 핵심 2가지
      - 인덱스 스캔 효율화 튜닝 : 인덱스 스캔 과정의 비효율을 줄이기
      - 테이블 액세스 횟수 저감 : 랜덤 액세스 최소화 튜닝
      - <h2>SQL튜닝은 랜덤IO와의 전쟁</h2>

  2.1.2 인덱스 구조
    - ROWID
      - = 데이터 블록 주소 + 로우 번호
      - 데이터 블록 주소 = 데이터 파일 번호 + 블록 번호
     
  2.1.3 인덱스 수직적 탐색
    - 인덱스 스캔 시작지점을 찾는 과정
    - → 피라미드와 같은 인덱스 구조에서(B* Tree) 원하는 값을 찾아 내려가다가 일치하는 인덱스가 있다면, 바로 그 전 인덱스가 가리키는 값으로 리프노드까지 내려간다.
    - → 즉, 조건을 만족하는 첫번째 레코드를 찾으면 끝이 나고, 수평탐색으로 전환된다.

  2.1.4 인덱스 수평적 탐색
    - 스캔 시작점을 찾았을 시, 찾고자 하는 데이터가 더 안나올 때까지 리프블록을 수평적으로 탐색하는 것.
    - 리프 블록은 양방향 연결 리스트다. (좌측 우측 양방향으로 탐색 가능)
    - 수평탐색의 목적 : 조건절을 만족하는 데이터 모두 찾기 위해, ROWID를 얻기 위해.
    - 인덱스가 조건을 해당하는 컬럼을 모두 갖고있지 않은 이상 인덱스를 스캔 후 테이블을 액세스 하기 때문에 ROWID가 필요하다.
      
  2.1.5 결합 인덱스 구조와 탐색
    - 고객테이블의 성별, 고객명을 합쳐서 인덱스를 만들 경우
    - → create index 고객_N1 on 고객(성별, 고객명);
    - (남, 이재희) 를 찾을 경우
    - 마찬가지로 (남, 이ㅊX) 바로 전의 인덱스 (남, 이재룡)이 가리키는 하위 블록으로 내려가서 (남, 이재희)에 해당하는 경우를 모두찾은 후 멈춘다.
    - 순서를 바꾸어서 계산해보면, <h3>'='조건으로 검색할 때는 인덱스 선두 컬럼이 무엇이든 블록IO갯수가 같고, 성능도 같다.</h3>
    - plus) B* Tree의 루트에서 리프 블록까지의 높이는 모두 항상 같다.

2.2 인덱스 기본 사용법
- range scan이 작동하는 방식을 알기 위해 range scan이 작동하지 않는 경우를 알아보자.

  2.2.1 인덱스를 사용한다는 것
    - 인덱스가 정렬돼있더라도 키값을 가공한 값이나 중간값으로는 <h3>스캔 시작점과 중단점을 찾을 수 없기 때문에 인덱스를 정상적으로 이용할 수 없다.</h3> 
    - 색인을 사용하긴 하지만 인덱스 전체를 스캔한다. (Index Full Scan)


※
07.10 69p ~ 86p
※


  2.2.2 인덱스를 Range Scan 할 수 없는 이유
    - <b>인덱스 컬럼을 가공하면</b> 인덱스를 정상적으로 사용(Range Scan)할 수 없다.
    - 인덱스 스캔 시작점과 끝 지점을을 알 수 없기 때문이다.
    - or절로 여러 컬럼에 조건을 거는 경우도 Range Scan할 수 없지만 이를 union all로 바꾸면 Index Range Scan이 가능하다.
      - 이를 Or Expansion이라고 한다.
    - in 조건에 대해서 옵티마이저는 INLIST ITERATOR를 반복하여 Range Scan을 수행한다.

  2.2.3 인덱스 사용 조건
    - 인덱스 선두 컬럼이 조건절에 있어야한다.
    - TXA_IX02 인덱스가 A + B + C 로 이루어져 있을 때 B나 C는 아무리 가공해도 테이블 INDEX RANGE SCAN이 가능하다.
      - 다만 인덱스 레인지 스캔이 가능할 뿐이지 성능은 보장되지 못한다.

  2.2.4 인덱스를 이용한 소트 연산 생략
    - 인덱스에 포함되는 컬럼만 조건을 걸고 조회하면 결과는 정렬돼있다.
      - 따라서 order by 조건을 걸어주어도 실행계획에는 SORT (ORDER By)에 해당하는 기록이 없다.
      - 인덱스 리프 블록은 양방향 연결리스트기 때문에 order by □ desc로 해도 마찬가지다.
  
  2.2.5 Order By 절에서 컬럼 가공
    - 인덱스 컬럼을 Where절에서 가공하면 인덱스를 정상적으로 사용할 수 없다고 상술하였다.
    - 하지만 ORDER BY나 SELECT-LIST에서 정렬된 순서와 다르게 컬럼을 기술하여도 정상적으로 이용하지 못할 수 있다.
    - ex) 장비번호, 변경일자, 변경순번으로 pk가 구성될 때, order by 변경일자||변경순번;~~

  2.2.6 SELECT-LIST에서 컬럼 가공
    - SELECT문의 컬럼에 MAX()와 같은 함수를 쓰는건 괜찮지만
    - substring()이나 toNumber()로 같은 함수로 가공을 해버리면 인덱스를 사용할 수 없다.
    - 그래서 스칼라 쿼리문으로 작성하면 하나는 괜찮지만 여러개 됐을 때 엄청나게 복잡해지고 가독성이 떨어진다.


※
07.11 86p ~ 103p
※
