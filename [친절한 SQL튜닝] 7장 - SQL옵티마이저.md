- 508p까지 작성한것 증발..

4. 시스템 통계
- 수집정보
  - CPU속도
  - 평균 Single Block IO속도
  - 평균 MultiBlock IO속도
  - 평균 MultiBlock IO개수
  - IO서브시스템의 최대처리량
  - 병렬Slave의 평균처리량
- 조회 쿼리
  ```sql
  select sname, pname, pval1, pval2 from sys.aux_stats$;
  ```

7.1.3 비용 계산 원리
- 인덱스 키 값을 모두 = 조건으로 검색할 때 필요한 통계정보
  - 비용 = BLEVEL + AVG_LEAF_BLOCKS_PER_KEY + AVG_DATA_BLOCKS_PER_KEY
  - 비용 = 인덱스 수직탐색비용 + 인덱스 수평탐색비용 + 테이블 랜덤 액세스 비용
- 인덱스 키 값이 모두 = 조건이 아닐 경우 컬럼 통계까지 활용
  - 비용 = BLEVEL + (LEAF_BLOCKS * 유효 인덱스 선택도) + (CLUSTERING_FACTOR * 유효 테이블 선택도)
  - 비용 = 인덱스 수직탐색비용 + 인덱스 수평탐색비용 + 테이블 랜덤 액세스 비용

7.2 옵티마이저에 대한 이해
- 
7.2.1 옵티마이저 종류
- CBO의 수행절차
  1. 실행계획 후보군 도출
  2. 데이터 딕셔너리에 수집도된 통계정보로 예상비용 산정
  3. 가장 낮은 비용의 실행게획 선택
- RBO는 통계정보를 활용하지 않고 규칙에만 의존하여 대량 데이터 처리에 부적합

7.2.2 옵티마이저 모드
1. ALL_ROWS : 전체 처리속도 최적화
2. FIRST_ROWS : 최초 응답속도 최적화 (Deprecated)
3. FIRST_ROWS_N : 최초 N건 응답속도 최적화
```sql
alert session set optimizer_mode = first_rows_10;
```

7.2.3 옵티마이저에 영향을 미치는 요소
1. SQL과 연산자 형태
2. 인덱스, IOT, 클러스터, 파티션, MV 등 옵티마이징 팩터
3. pk, fk, check, not null과 같은 제약 설정
4. 통계 정보
   - 다음과 같은 경우에 시스템 장애 발생 가능
     - 특정 테이블 통계정보 삭제
     - 데이터 삭제 후 대량 데이터 입력 시, 입력 전에 통계 데이터 수집
     - 장기간 갱신하지 않던 통계정보를 재수집
     - 통계정보 없는 테이블에 인덱스 재생성
     - 테이블/인덱스 재생성시 파티션 단위로만 통계정보 수집
5. 옵티마이저 힌트
   - 다음의 경우 힌트 미작동
     1. 문법 오류
     2. 잘못된 참조
     3. 의미적으로 충돌나는 힌트
     4. 논리적으로 불가능한 액세스 경로
     5. 버그
6. 옵티마이저 관련 파라미터
   - 버전 업그레이드 시 파라미터가 바뀌어 힌트가 미작동 할 수 있음
     ```sql
     select name, value, isdefault, default_value
     from v$sys_optimizer_env
     ```

7.2.4 옵티마이저의 한계
- 완벽환 상황과 조건 속에서도 항상 최선의 실행계획으로 실행할 순 없다.

7.2.5 개발자의 역할
- 옵티마이저에게 맡기지만 항상 실행계획을 점검하고 개선해야한다.
1. 필요한 최소 블록만 읽도록 쿼리 작성
   - 불필요한 조회작업, 조인 제거
2. 최적의 옵티마이징 팩터 제공
   - 전략적인 인덱스 구성
   - DBMS의 다양한 기능 활용 : 파티션, 클러스터, IOT, MV, Result Cache 등
   - 옵티마이저 모드 설정
   - 정확한 통계정보
3. 필요시 옵티마이저 힌트를 제공하여 최적화

7.2.6 튜닝 전문가 되는 공부방법
- 데이터베이스 튜닝 = 성능 튜닝
- 튜닝의 대상은 파일이 아닌 DBMS라는 소프트웨어
- 튜닝 대상
  1. SQL : IO효율, DB Call, SQL파싱 최소화 
  2. DB설계 : 논리적 데이터 구조, 물리적 저장 구조
  3. 인스턴스 튜닝 : Lock/Latch 모니터링 및 해소, 메모리 설정, 프로세스 설정
