2.1 인덱스 구조 및 탐색
- 인덱스 탐색과정은 수직적 탐색과 수평적 탐색 단 두가지 단계로 이루어진다.

  2.1.1 미리 보는 인덱스 튜닝
    - 데이터를 찾는 두가지 방법 -> 테이블 전체 스캔, 인덱스이용
    - 인덱스 : 큰 테이블에서 소량의 데이터를 검색할 때 사용 -> OLTP애서 특히 중요
    - 인덱스 튜닝의 핵심 2가지
      - 인덱스 스캔 효율화 튜닝 : 인덱스 스캔 과정의 비효율을 줄이기
      - 테이블 액세스 횟수 저감 : 랜덤 액세스 최소화 튜닝
      - <h2>SQL튜닝은 랜덤IO와의 전쟁</h2>

  2.1.2 인덱스 구조
    - ROWID
      - = 데이터 블록 주소 + 로우 번호
      - 데이터 블록 주소 = 데이터 파일 번호 + 블록 번호
     
  2.1.3 인덱스 수직적 탐색
    - 인덱스 스캔 시작지점을 찾는 과정
    - → 피라미드와 같은 인덱스 구조에서(B* Tree) 원하는 값을 찾아 내려가다가 일치하는 인덱스가 있다면, 바로 그 전 인덱스가 가리키는 값으로 리프노드까지 내려간다.
    - → 즉, 조건을 만족하는 첫번째 레코드를 찾으면 끝이 나고, 수평탐색으로 전환된다.

  2.1.4 인덱스 수평적 탐색
    - 스캔 시작점을 찾았을 시, 찾고자 하는 데이터가 더 안나올 때까지 리프블록을 수평적으로 탐색하는 것.
    - 리프 블록은 양방향 연결 리스트다. (좌측 우측 양방향으로 탐색 가능)
    - 수평탐색의 목적 : 조건절을 만족하는 데이터 모두 찾기 위해, ROWID를 얻기 위해.
    - 인덱스가 조건을 해당하는 컬럼을 모두 갖고있지 않은 이상 인덱스를 스캔 후 테이블을 액세스 하기 때문에 ROWID가 필요하다.
      
  2.1.5 결합 인덱스 구조와 탐색
    - 고객테이블의 성별, 고객명을 합쳐서 인덱스를 만들 경우
    - → create index 고객_N1 on 고객(성별, 고객명);
    - (남, 이재희) 를 찾을 경우
    - 마찬가지로 (남, 이ㅊX) 바로 전의 인덱스 (남, 이재룡)이 가리키는 하위 블록으로 내려가서 (남, 이재희)에 해당하는 경우를 모두찾은 후 멈춘다.
    - 순서를 바꾸어서 계산해보면, <h3>'='조건으로 검색할 때는 인덱스 선두 컬럼이 무엇이든 블록IO갯수가 같고, 성능도 같다.</h3>
    - plus) B* Tree의 루트에서 리프 블록까지의 높이는 모두 항상 같다.

2.2 인덱스 기본 사용법
- range scan이 작동하는 방식을 알기 위해 range scan이 작동하지 않는 경우를 알아보자.

  2.2.1 인덱스를 사용한다는 것
    - 인덱스가 정렬돼있더라도 키값을 가공한 값이나 중간값으로는 <h3>스캔 시작점과 중단점을 찾을 수 없기 때문에 인덱스를 정상적으로 이용할 수 없다.</h3> 
    - 색인을 사용하긴 하지만 인덱스 전체를 스캔한다. (Index Full Scan)


- ※07.10 69p ~ 86p※


  2.2.2 인덱스를 Range Scan 할 수 없는 이유
    - <b>인덱스 컬럼을 가공하면</b> 인덱스를 정상적으로 사용(Range Scan)할 수 없다.
    - 인덱스 스캔 시작점과 끝 지점을을 알 수 없기 때문이다.
    - or절로 여러 컬럼에 조건을 거는 경우도 Range Scan할 수 없지만 이를 union all로 바꾸면 Index Range Scan이 가능하다.
      - 이를 Or Expansion이라고 한다.
    - in 조건에 대해서 옵티마이저는 INLIST ITERATOR를 반복하여 Range Scan을 수행한다.

  2.2.3 인덱스 사용 조건
    - 인덱스 선두 컬럼이 조건절에 있어야한다.
    - TXA_IX02 인덱스가 A + B + C 로 이루어져 있을 때 B나 C는 아무리 가공해도 테이블 INDEX RANGE SCAN이 가능하다.
      - 다만 인덱스 레인지 스캔이 가능할 뿐이지 성능은 보장되지 못한다.

  2.2.4 인덱스를 이용한 소트 연산 생략
    - 인덱스에 포함되는 컬럼만 조건을 걸고 조회하면 결과는 정렬돼있다.
      - 따라서 order by 조건을 걸어주어도 실행계획에는 SORT (ORDER By)에 해당하는 기록이 없다.
      - 인덱스 리프 블록은 양방향 연결리스트기 때문에 order by □ desc로 해도 마찬가지다.
  
  2.2.5 Order By 절에서 컬럼 가공
    - 인덱스 컬럼을 Where절에서 가공하면 인덱스를 정상적으로 사용할 수 없다고 상술하였다.
    - 하지만 ORDER BY나 SELECT-LIST에서 정렬된 순서와 다르게 컬럼을 기술하여도 정상적으로 이용하지 못할 수 있다.
    - ex) 장비번호, 변경일자, 변경순번으로 pk가 구성될 때, order by 변경일자||변경순번;~~

  2.2.6 SELECT-LIST에서 컬럼 가공
    - SELECT문의 컬럼에 MAX()와 같은 함수를 쓰는건 괜찮지만
    - substring()이나 toNumber()로 같은 함수로 가공을 해버리면 인덱스를 사용할 수 없다.
    - 그래서 스칼라 쿼리문으로 작성하면 하나는 괜찮지만 여러개 됐을 때 엄청나게 복잡해지고 가독성이 떨어진다.


- ※ 07/11 86p ~ 104p ※


  2.2.7 자동형변환
    - where 생년월일 = 19821225 같은 where 조건절이 있을 때,
    - 옵티마이저는 문자형인 생년월일과 19821225를 비교하기 위해 TO_NUMBER(생년월일)과 같이 자료형을 맞추어서 실행시킨다.
    - 따라서 인덱스절이 자동으로 가공되므로 Range Scan 할 수 없다.
      - 따라서 TO_DATE('19921225','YYYYDD') 같은 함수로 형을 일치시킨 후 사용한다.
    - NumberColumn LIKE '%good%' 같은 like구문은 반대로 숫자형을 문자형으로 변환시킨다.
    - <b>→ 형변환같은 조건들을 명확하게 명시하라!</b>

2.3 인덱스 확장기능 사용법
- 인덱스 확장기능

  2.3.1 Index Range Scan
    - B* Tree의 가장 일반적인 형태의 액세스 방식
    - 인덱스 루트에서 리프 블록까지 수직적으로 탐색 후 수평적으로 필요한 범위만 탐색한다.
    - 인덱스 선두컬럼을 가공하지 않은 경우 사용 가능
  
  2.3.2 Index Full Scan
    - 수직탐색 없이 인덱스 리프블록을 전체 스캔하는 방식
    - 최적의 인덱스가 없을 때 차선으로 선택됨
    - ex) (ename, sal)로 인덱스를 구성했는데 sal>2000인 레코드를 찾고자 하는 경우
    - Table Full Scan보다는 효율적이지만, 수행빈도가 잦다면 인덱스를 새로 생성해주는 것이 좋다.
  
  2.3.3 Index Unique Scan
    - 수직 탐색으로만 데이터를 찾는 스캔방법
    - Unique 인덱스를 '=' 조건으로 탐색할때만 작동한다.
    - 또한 결합인덱스의 일부 컬럼만으로 검색할때도 나타난다. ex) (emp, sal, com)인덱스에서 emp와 sal로만 검색하는 경우

  2.3.4 Index Skip Scan
    - 선두 컬럼이 조건절에 없어도 사용할 수 있는 스캔 방법
    - 선두 컬럼의 Distinct Value가 적고 (ex 성별) 후행 컬럼의 Distinct Value가 적을 때 유용.(ex 고객번호, 연봉)
    - 조건절에 해당하는 레코드가 있을 수 있는 리프블록은 액세스하고 없는 리프블록은 액세스하지 않는다.
    - (sex,sal,day) 인덱스가 있을 때 sex와 day로만 검색을 하는 경우에도 사용 가능
      - Range Scan이라면 sex가 ㅁ인 경우를 모두 스캔해야하지만,
      - Index Skip Scan이라면 day 기준에 속할 수 없는 리프 블록들은 스킵할 수 있다.
    - 조건절에 distinct value가 적은 인덱스 선두 컬럼이 없는 경우에도 유용하다.
      - → distinct value가 많은 컬럼으로 검색시 액세스하지 않고 스킵해도 되는 리프블록이 많아지기 때문에
    - 선두컬럼이 between, like같은 범위검색 조건일때도 유용
      - ex) 기준일자 + 업종유형코드 결합인 인덱스일 때 업종유형코드에 속할 수 없는 리프블록들은 skip할 수 있다.
        - → 업정유형코드는 dintinct value가 많다.

  2.3.5 Index Fast Full Scan
    - 논리적인 인덱스 트리 구조를 무시하고 인덱스 <b>세그먼트 전체</b>를 Multiblock I/O 방식으로 탐색
    - Multiblock I/O 방식을 사용하며 대량의 인덱스 블록을 읽어야 할 때 유용
    - 빠르지만 <b>결과가 정렬되지 않고, 쿼리에 사용한 컬럼이 모두 인덱스에 포함되어야</b> 사용할 수 있다..
    - Index Range Scan, Index Full Scan과 달리 인덱스가 파티션돼있지 않아도 병렬쿼리가 가능하다.
    - 병렬쿼리일 경우 Direct Path I/O 방식을 사용하여 더 빨라짐
    
  2.3.6 Index Range Scan Descending
    - Range Scan을 뒤에서 수행
    - 결과집합이 내림차순으로 정렬됨
    - 인덱스를 선두컬럼으로 탐색하고 내림차순으로 정렬하면 옵티마이저가 시행함
    - MAX값을 구할때도 자동으로 옵티마이저가 수행

- ※ 07/12 104p ~  125p ※
