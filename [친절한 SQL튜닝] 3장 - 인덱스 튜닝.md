3.1 테이블 액세스 최소화
- SQL튜닝은 랜덤IO와의 전쟁

  3.1.1 테이블 랜덤 액세스
    - 인덱스 ROWID는 물리주소? 논리주소? 논리주소에 가깝다. (인덱스 ROWID는 데이터파일 번호, 오브젝트 번호, 블록 번호로 이루어짐)
    - 인덱스 ROWID를 통한 테이블 접근은 포인터를 통한 접근이 아닌 DBA(Data Block Adress, 데이터가 디스크에 있는 주소)를 통한 접근이다. 메인메모리를 통한 접근보다 느리다.
    - 오라클은 버퍼캐시의 DBA(디스크 주소 정보)를 이용해 해시알고리즘으로 버퍼 블록을 찾아간다. 반면 메인 메모리 DB는 메모리 상의 주소정보(포인터)를 갖기때문에 훨씬 빠르다.
    - I/O 메커니즘 : 버퍼캐시를 찾고, DBA를 해쉬 함수에 넣어서 해시체인을 찾고 거기서 버퍼헤더를 찾는다.
    - 인덱스로 접근 시 : 리프블록에서 얻은 ROWID로 DBA를 얻고, FULL SCAN시엔 익스텐트 맵에서 읽을 블록들의 DBA 얻음
    - <b>인덱스 ROW ID는 포인터가 아님!</b>
    - 인덱스 ROW ID는 포인터가 아니며, 디스크 상의 테이블 레코드를 찾아가기 위한 논리적인 주소 정보.
    - 버퍼캐시에서 테이블 블록을 먼저 찾아보고 없을 때에만 디스크에서 블록을 잃는다,
    - 버퍼캐시에 데이터가 있더라도 DBA해싱과 래치획득을 매번 반복해야한다. 경합마저 발생 가능
    - TABLE ACCESS (BY INDEX ROWID) OF '고객' 와 같은 ROWID를 통한 데이터 접근은 생각보다 고비용이다!
 
  3.1.2 인덱스 클러스터링 팩터 CF ~= 군집성 계수
  : 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도 (물리적으로)
  - 물리적으로 같은 블록에 위치하면 (래치 획득과 체인 스캔 과정)을 생략하고(블록 IO를 생략하고) 바로 데이터에 접근할 수 있기 때문

  3.1.3 인덱스 손익분기점
  - Index Range Scan에 의한 테이블 액세스가 Table Full Scan보다 느려지는 지점
  - 이유
    - Table Full Scan : 시퀀셜 액세스, Multiblock IO
    - Index Range Scan : 랜덤 액세스, Single Block IO
  - 보통 5~20%의 낮은 수준을 이룬다. CF가 좋으면 90%까지 상승, 테이블 데이터가 100만, 1000만이 넘어가면 사실상 없는 수준

- ※ 07/14 129p ~ 145p ※

3.1.4 인덱스 컬럼 추가
- 일반적으로 튜닝을 위해 사용하는 기법 : 기존에 존재하는 인덱스에 <b>자주 조건으로 사용되는 컬럼을 추가</b>한다.

3.1.5 인덱스만 읽고 처리
- 인덱스로 스캔한 데이터가 버리게 되는 것은 거의 없지만 절대 데이터량이 많아서 느려지는 경우 어쩔 수 없다.
- 하지만 쿼리에 사용된 모든 컬럼을 인덱스에 추가하여 테이블 액세스를 없애는 방법이 있다. <b>Covered Index</b>
- <b>Include Index</b>
  - 인덱스와 별도로 지정한 컬럼을 리프 레벨에 함께 저장하는 기능(SQL Server)
    - ex1) create index emp_x01 on emp (deptno) include (sal)
    - ex2) create index emp_x02 on emp (deptno, sal)
    - ex1은 수직탐색에는 sal을 사용할 수 없다. sal컬럼은 테이블 액세스를 줄이기 위해서만 사용된다.

3.1.6 인덱스 구조 테이블
- 랜덤 액세스가 발생하지 않도록 테이블 자체를 인덱스 구조로 구성. IOT; Index-Organized Table / Clustered Index
- 인덱스가 ROWID를 갖지 않고 테이블 데이터 자체를 갖는다. 인덱스 리프 블록 = 데이터 블록
- oracle에서 create table 구문 맨 끝에 organization index; 로 구성 (일반테이블은 organization heap)
- ex) create table index_org_t ( a number, b varchar(10), constraint index_org_t_pk primary key (a) ) organization index;
- 랜덤 액세스가 아닌 시퀀셜 액세스 -> Between/부등호 조건에도 유리

3.1.7 클러스터 테이블
- 인덱스 클러스터/해시 클러스터
- <b>인덱스 클러스터 테이블</b>
  - 클러스터 키 값이 같은 레코드를 한 블록에 모아서 저장하는 구조. 정렬하지는 않음
  - 한 블록에 담기지 않을 경우 새로운 블록에 할당해서 클러스터 체인으로 연결
  - 여러 테이블 레코드를 한 블록에 저장할 수도 있음 (다중 테이블 클러스터)
  - ex)
    - create cluster c_dept# ( deptno number(2) ) <b>index</b>;
    - create index c_dept#_index on cluster c_dept#;
    - create table dept( deptno number(2) not null, dname varchar2(14) not null, loc varchar2(13) ) cluster c_dept#(deptno);
  - 일반 인덱스는 테이블 레코드와 1:1 관계지만, 클러스터 인덱스는 테이블 레코드와 1:M 관계이다. (ex. deptno) 따라서 중복값이 없다.
  - 인덱스 클러스터 테이블은 랜덤 액세스가 값 하나당 한 번 밖에 일어나지 않음.(클러스터 체인을 스캔할 때 생기는 랜덤 액세스 제외)
    - 따라서 넓은 범위를 읽어도 비효율 X
- <b>해시 클러스터 테이블 테이블</b>
  - 인덱스를 사용하지 않고 해시 알고리즘을 사용해 클러스터를 찾아는 것만 다름

3.2 부분범위 처리 활용

3.2.1 부분범위 처리
- DBMS는 일정량의 데이터를 나누어서 전송한다. 자바의 기본 Array Size는 10으로 Statement객체의 setFetchSize 메소드로 변경할 수 있다.
  - 최초 rs.next() 호출 시 10건을 캐시에 저장하고 다음 9번의 호출은 캐시에서 읽는다.
- 정렬조건이 있을 시 DB서버는 전체 결과를 읽어야 데이터를 전송하기 시작한다.
  - order by 조건이 선두인 인덱스가 있을 경우 부분 범위 처리 가능
- 따라서 대용량 데이터를 전송할 때 그 데이터를 거의 버리지 않는다면 Array Size를 증가할 필요가 있고 (Fetch 횟수 감소)
- 보통 데이터를 로드하다가 앞부분만 읽고 버리게된다면 Array Size를 줄일 필요가 있다. (반환속도 증가)

3.2.2 부분범위 처리 구현
- 자바 프레임워크로 구현되어있다.

3.2.3 OLTP 환경에서 부분범위 처리에 의한 성능개선 원리
- 인덱스와 부분범위 처리 원리는 활용하여 OLTP환경 등에서 극적인 성능개선 효과를 얻을 수 있다.
  - 조건절의 컬럼을 선두조건, 정렬조건을 후행조건으로 인덱스를 구성한다
- 배치IO : 디스크 IO를 즉각즉각 처리하지 않고 일정량 쌓이면 한꺼번에 처리
  - 데이터 정렬 이슈 : 배치 IO가 작동하면 데이터 정렬 순서가 매번 다를 수 있다.
  - 인덱스로 정렬이 보장돼있는 쿼리라도 Batch 힌트로 batch 기능이 작동한 경우 실행계획에 sort order by 가 포함될 수 있다.

- ※ 07/15(토) 146p ~ 172p ※


