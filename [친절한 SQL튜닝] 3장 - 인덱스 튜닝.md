3.1 테이블 액세스 최소화
- SQL튜닝은 랜덤IO와의 전쟁

  3.1.1 테이블 랜덤 액세스
    - 인덱스 ROWID는 물리주소? 논리주소? 논리주소에 가깝다. (인덱스 ROWID는 데이터파일 번호, 오브젝트 번호, 블록 번호로 이루어짐)
    - 인덱스 ROWID를 통한 테이블 접근은 포인터를 통한 접근이 아닌 DBA(Data Block Adress, 데이터가 디스크에 있는 주소)를 통한 접근이다. 메인메모리를 통한 접근보다 느리다.
    - 오라클은 버퍼캐시의 DBA(디스크 주소 정보)를 이용해 해시알고리즘으로 버퍼 블록을 찾아간다. 반면 메인 메모리 DB는 메모리 상의 주소정보(포인터)를 갖기때문에 훨씬 빠르다.
    - I/O 메커니즘 : 버퍼캐시를 찾고, DBA를 해쉬 함수에 넣어서 해시체인을 찾고 거기서 버퍼헤더를 찾는다.
    - 인덱스로 접근 시 : 리프블록에서 얻은 ROWID로 DBA를 얻고, FULL SCAN시엔 익스텐트 맵에서 읽을 블록들의 DBA 얻음
    - <b>인덱스 ROW ID는 포인터가 아님!<b/>
    - 인덱스 ROW ID는 포인터가 아니며, 디스크 상의 테이블 레코드를 찾아가기 위한 논리적인 주소 정보.
    - 버퍼캐시에서 테이블 블록을 먼저 찾아보고 없을 때에만 디스크에서 블록을 잃는다,
    - 버퍼캐시에 데이터가 있더라도 DBA해싱과 래치획득을 매번 반복해야한다. 경합마저 발생 가능
    - TABLE ACCESS (BY INDEX ROWID) OF '고객' 와 같은 ROWID를 통한 데이터 접근은 생각보다 고비용이다!
 
  3.1.2 인덱스 클러스터링 팩터 CF ~= 군집성 계수
  : 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도 (물리적으로)
  - 물리적으로 같은 블록에 위치하면 (래치 획득과 체인 스캔 과정)을 생략하고(블록 IO를 생략하고) 바로 데이터에 접근할 수 있기 때문

  3.1.3 인덱스 손익분기점
  - Index Range Scan에 의한 테이블 액세스가 Table Full Scan보다 느려지는 지점
  - 이유
    - Table Full Scan : 시퀀셜 액세스, Multiblock IO
    - Index Range Scan : 랜덤 액세스, Single Block IO
  - 보통 5~20%의 낮은 수준을 이룬다. CF가 좋으면 90%까지 상승, 테이블 데이터가 100만, 1000만이 넘어가면 사실상 없는 수준

- ※ 07/14 129p ~ 145p ※

3.1.4 인덱스 컬럼 추가
