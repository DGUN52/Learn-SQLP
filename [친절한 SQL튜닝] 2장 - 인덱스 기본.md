※
07.10 69p ~
※

2.1 인덱스 구조 및 탐색
- 인덱스 탐색과정은 수직적 탐색과 수평적 탐색 단 두가 단계로 이루어진다.

  2.1.1 미리 보는 인덱스 튜닝
    - 데이터를 찾는 두가지 방법 -> 테이블 전체 스캔, 인덱스이용
    - 인덱스 : 큰 테이블에서 소량의 데이터를 검색할 때 사용 -> OLTP애서 특히 중요
    - 인덱스 튜닝의 핵심 2가지
      - 인덱스 스캔 효율화 튜닝 : 인덱스 스캔 과정의 비효율을 줄이기
      - 테이블 액세스 횟수 저감 : 랜덤 액세스 최소화 튜닝
      - <h2>SQL튜닝은 랜덤IO와의 전쟁</h2>

  2.1.2 인덱스 구조
    - ROWID
      - = 데이터 블록 주소 + 로우 번호
      - = 데이터 블록 주소 = 데이터 파일 번호 + 블록 번호
     
  2.1.3 인덱스 수직적 탐색
    - 인덱스 스캔 시작지점을 찾는 과정
    - → 피라미드와 같은 인덱스 구조에서(B* Tree) 원하는 값을 찾아 내려가다가 일치하는 인덱스가 있다면, 바로 그 전 인덱스가 가리키는 값으로 리프노드까지 내려간다.
    - → 즉, 조건을 만족하는 첫번째 레코드를 찾으면 끝이 나고, 수평탐색으로 전환된다.

  2.1.4 인덱스 수평적 탐색
    - 스캔 시작점을 찾았을 시, 찾고자 하는 데이터가 더 안나올 때까지 리프블록을 수평적으로 탐색하는 것.
    - 리프 블록은 양방향 연결 리스트다. (좌측 우측 양방향으로 탐색 가능)
    - 수평탐색의 목적 : 조건절을 만족하는 데이터 모두 찾기 위해, ROWID를 얻기 위해.
    - 인덱스가 조건을 해당하는 컬럼을 모두 갖고있지 않은 이상 인덱스를 스캔 후 테이블을 액세스 하기 때문에 ROWID가 필요하다.
      
  2.1.5 결합 인덱스 구조와 탐색
    - 고객테이블의 성별, 고객명을 합쳐서 인덱스를 만들 경우
    - → create index 고객_N1 on 고객(성별, 고객명);
    - (남, 이재희) 를 찾을 경우
    - 마찬가지로 (남, 이ㅊX) 바로 전의 인덱스 (남, 이재룡)이 가리키는 하위 블록으로 내려가서 (남, 이재희)에 해당하는 경우를 모두찾은 후 멈춘다.
    - 순서를 바꾸어서 계산해보면, <h3>'='조건으로 검색할 때는 인덱스 선두 컬럼이 무엇이든 블록IO갯수가 같고, 성능도 같다.</h3>
    - plus) B* Tree의 루트에서 리프 블록까지의 높이는 모두 항상 같다.

2.2 인덱스 기본 사용법
- range scan이 작동하는 방식을 알기 위해 range scan이 작동하지 않는 경우를 알아보자.

  2.2.1 인덱스를 사용한다는 것
    - 인덱스가 정렬돼있더라도 키값을 가공한 값이나 중간값으로는 <h3>스캔 시작점과 중단점을 찾을 수 없기 때문에 인덱스를 정상적으로 이용할 수 없다.</h3> 
    - 색인을 사용하긴 하지만 인덱스 전체를 스캔한다. (Index Full Scan)

  2.2.2 인덱스를 Range Scan 할 수 없는 이유
    - 인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용(Range Scan)할 수 없다.
    - 인덱스 스캔 시작점과 끝 지점을을 알 수 없기 때문이다.
    - 





