1.1.1 SQL파싱과 최적화
 - SQL은 선언적, 집합적, 구조적 질의 언어
 - DBMS가 선언을 실행가능 상태로 만드는 전 과정을 SQL최적화라고 한다.

1.1.2 SQL최적화
 - SQL최적화 = SQL 파싱 + SQL 최적화 + 로우 소스 생성
  - SQL 파싱 : SQL파서가 파싱 트리 생성, Syntax(문법오류) 체크, Semantic 체크 (테이블/컬럼이 존재하는지, 권한이 있는지)
  - SQL 최적화(경로설정) : SQL옵티마이저가 다양한 실행경로 중 가장 효율적인 방법 선택
  - 로우 소스 생성 : 로우 소스 생성기가 선택된 실행경로를 실제 실행 가능한 코드/프로시저 형태로 포맷팅

1.1.3 SQL옵티마이저
  - DBMS의 핵심 엔진
  - 옵티마이저의 최적화 단계
    1) 후보군이 될만한 실행계획을 찾아냄
    2) 데이터 딕셔너리에 미리 수집된 오브젝트 통계 및 시스템 통계를 이용해 각 실행계획의 비용 산정
    3) 최저 비용이 예상되는 실행계획 선택 

1.1.4 실행계획과 비용
  - 실행계획 Execution Plan 을 통해 SQL의 동작방식이 예상대로인지 확인할 수 있다.
  - 실행계획에 표시되는 비용과 실제 실행했을 때의 비용은 차이가 많이 날 수 있다.

1.1.5 옵티마이저 힌트
  1. 주석기호에 +를 붙여 사용하며, SQL이 특정 실행계획대로 작동하게 한다.<BR>
    - EX) SELECT /*+ INDEX(A 고객_PK) */<br>
                고객명, 연락처, 주소<br>
        FROM 고객 A<br>
        WHERE 고객ID = '012345'
  2. 힌트와 힌트 사이엔 ,를 사용하면 안된다.<BR>
    - EX) /*+ INDEX(C), FULL(D) */ → 무효
  3. 스키마명을 명시하지 않는다.<BR>
    - EX) SELECT /*+ FULL(SCOTT.EMP) */ → 무효
  4. 별칭 ALIAS를 지정했다면 ALIAS를 무조건 명시해준다.<BR>
    - EX) SELECT /*+ FULL(EMP) */<BR>
  FROM EMP E<BR>
  → 무효
  
  
  ※ 27p 자주 사용하는 힌트 목록
  
  
1.2 SQL 공유 및 재사용
1.2.1 소프트 파싱 VS 하드 파싱
  - 프로시저를 재사용할 수 있게 캐싱해 두는 메모리공간 : 라이브러리 캐시 ; SGA의 구성요소
    - 프로시저 : SQL 파싱, 최적화, 로우 소스 생성 과정을 거친 결과물
  - 사용자가 SQL을 전달하면 파싱되고
    - 파싱된 것이 캐시에 있다면 : 바로 실행 → 소프트 파싱
    - 파싱된 것이 캐시에 없다면 : 최적화, 로우 소스 생성 → 하드 파싱
  
  - 옵티마이저가 사용하는 정보
    - 테이블, 컬럼, 인덱스 구조에 관한 기본정보
    - 오브젝트 통계 : 테이블, 인덱스, 컬럼 통계
    - 시스템 통계 : CPU속도, Single Block I/O속도, MultiBlock I/O 속도 등
    - 옵티마이저 관련 파라미터
  
1.2.2 바인드 변수의 중요성
  - SQL은 이름이 없다. 이름을 지어주고 모든 SQL을 저장하는 것은 많은 용량을 요하고 SQL을 찾는 속도를 느려지게 한다.
  - 대소문자 하나, 철자 하나만 달라져도 별개로 최적화를 진행하고 SGA->라이브러리의 캐시에서도 별도 공간을 사용한다.
  - 자바의 PreparedStatement 같은 기능(?에 값을 집어넣는 쿼리)을 이용하면 중복되는 SQL을 바인드변수를 통해 한 건의 하드파싱으로 처리한다.
  
1.3 데이터 저장 구조 및 I/O 메커니즘
  - I/O가 빨라져야 SQL이 빨라진다.
1.3.2 데이터베이스 저장구조
  - 테이블 스페이스 : 세그먼트를 담는 콘테이너
    - 세그먼트(테이블) : 데이터 저장공간이 필요한 오브젝트(테이블, 인덱스, 파티션, LOB 등)
      - 익스텐트 : 저장공간 부족 시 공간을 확장하는 단위 (연속된 블록으로 구성)
        - 블록 : 데이터를 읽고 쓰는 단위
          - 로우
  - DB2, SQL Server는 블록 대신 페이지(Page), 하나의 페이지는 하나의 테이블이 독점. 한 블록(페이지)에 저장된 레코드는 모두 같은 테이블 레코드
  - 하나의 세그먼트에 있는 익스텐트는 여러 데이터 파일로 저장돼있을 가능성이 더 높다.(파일 경합을 줄이기 위해 DBMS가 분산하여 저장)
  
  - DBA(Data Block Address) : 데이터 블록이 디스크 상에서 몇 번 데이터파일의 몇 번째 블록인지 나타내는 자신만의 고유 주소값

※
[06/21 17p~43p]
※
  
1.3.3 블록 단위 I/O
- 읽고쓰는 단위인 블록단위로 읽기 때문에 한 행만 조회하고 싶어도 블록을 다 읽는다.(오라클 8KB)
- 테이블, 인덱스 동일하게 블록단위로 Read&Write

1.3.4 시퀀셜 액세스 vs 랜덤 액세스
- 시퀀셜 액세스 : 앞 혹은 뒤로 순차적으로 데이터에 접근
  - 인덱스 : 리프블록끼리  앞뒤로 논리적으로 연결돼어있음
  - 테이블 : 세그먼트 헤더에는 세그먼트에 할당된 익스텐트 목록이 맵으로 저장돼있음. 맵은 각 익스텐트의 첫번째 블록 주소가 저됨
- 랜덤 액세스 : 논리적 물리적 순서와 상관없이 한 블록씩 접근

1.3.5 논리적 I/O vs 물리적 I/O
- 디스크 I/O가 성능을 결정한다!
  - ->데이터 캐싱 매커니즘 필요
- SGA의 라이브러리 캐시도 중요하지만 DB 버퍼캐시도 중요하다.
  - 라이브러리 캐시는 '코드 캐시', DB 버퍼캐시는 '데이터 캐시'
    - 읽었던 데이터 블록을 캐싱해두고 나중의 블록 탐색에서 버퍼캐시에 원하는 데이터가 있다면 I/O Call 단계로 넘어가지 않는다.

<p></p>

- 논리적 블록 I/O : SQL 처리 과정에서 발생한 총 블록 IO (메모리IO + Direct Path IO)
  - → 버퍼캐시에서 찾는 경우도 포함 → 메모리I/O = 전기적 신호
- 물리적 블록 I/O : 디스크에서 발생한 총 블록 IO (버퍼캐시에서 찾지 못하고 디스크를 액세스 하는 IO)
  - → 디스크 IO = 디스크 암을 통한 물리적 호출(느림)
  
<p></p>

- 버퍼캐시 히트율 BCHR
  - = ( 캐시에서 바로 찾은 블록 수 / 총 읽은 블록 수 ) x 100
  - = ( ( 논리적 IO - 물리적 IO ) / 논리적 IO ) x 100
  - = ( 1 - 물리적 IO / 논리적 IO ) x 100
 
  - <h4>통제불가능한 외생변수인 물리적 IO를 줄이기보단 논리적 IO를 줄여야 성능을 향상시킬 수 있다.</h2>
    - SQL 튜닝을 통해 읽는 총 블록 개수를 줄인다.
    - BCHR이 높다고 성능이 좋다는 뜻은 아니다. (같은 블록을 여러번 읽음으로써 히트율 향상될 수 있음)

1.3.6 Single Block I/O vs Multiblock I/O
- 캐시에서 찾지 못한 데이터 블록은 IO Call을 통해 캐시에 적재하고 읽는다.
  - IO Call을 한블록씩/여러블록씩 하느냐에 따라 Single/Multi
  - 인덱스는 소량의 데이터를 찾을 때 사용하므로 Single Block I/O 방식이 효율적이다. 다음의 상황들도 싱글블락IO이다.
    - 인덱스 루트 블록을 읽을 때
    - 인덱스 루트 블록에서 얻은 주소정보로 -> 브랜치 블록을 읽을 때
    - 브랜치 블록 -> 리프 블록
    - 리프 블록 -> 테이블 블록
  - 많은 데이터 블록을 읽는 table full scan 시 Multi block I/O 방식이 효율적이다.
  - Multiblock I/O 방식으로 진행하더라도 Single block I/O가 나타날 수 있다.

1.3.7 Table Full Scan vs Index Range Scan
- 소량의 데이터를 찾는게 아니라면 table full scan의 성능이 더 좋을 확률이 높다.
  - table full scan은 멀티블락IO에 순차적으로 읽기 때문에 자원낭비를 하지 않지만 Index를 이용한 접근은 싱글블락IO에 랜덤 액세스 하기 때문이다.
  - 따라서 다량의 데이터 검색 시 논리적인 측면, 물리적 측면 모두 손해를 볼 수 있다.
  - 읽었던 블록을 다시 읽는 단점도 가지고 있다(index range scan)
 
1.3.8 캐시 탐색 매커니즘
- Direct Path I/O를 제외한 모든 블록I/O는 메모리 버퍼캐시를 거친다.
- 버퍼캐시는 해시구조로 관리된다
  - 만약 해시구조가 5갈래이고 '20번 블록'이 3번 갈래에 있어야한다면(해시함수를 통해) 3번째 갈래만 확인하면 된다.
    - 3번째 갈래에 없다면 다른 갈래를 탐색할 필요 없이 물리적 IO를 통해 버퍼캐시에 적재 후 읽어들인다.
- 즉 버퍼캐시에서 버퍼 헤더를 찾고, 버퍼 헤더에서 찾은 포인터로 버퍼 블록에 액세스하는 방식을 사용한다.
- 해시구조의 특징
  - 같은 입력 값은 항상 동일한 해시 체인에 연결됨
  - 다른 입력 값이 동일한 해시 체인에 연결될 수 있음
  - 해시 체인 내 정렬 보장 X
    
 <p></p>

- 버퍼캐시는 공유자원이므로 경합이 발생할 수 있기에 직렬화가 필요하다.
- Latch 래치 : 직렬화를 지원하는 매커니즘 (자물쇠와 키(버퍼 락))
  - SGA를 구성하는 서브 캐시마다 별도의 래치 존재
  - 버퍼캐시 > 캐시버퍼 체인 래치, 캐시버퍼 LRU 체인 래치 등
    - 버퍼캐시 히트율이 높아도 래치에 의한 경합이 많다면 생각만큼 빠르지 않을 수 있다.
      - -> SQL 튜닝을 통해 쿼리 일량(논리적 I/O) 자체를 줄여야 한다.

※
[06/29 44p~66p]
※
