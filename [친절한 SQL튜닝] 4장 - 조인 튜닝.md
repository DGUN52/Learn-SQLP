4.1 NL조인
- 
4.1.1 기본 메커니즘
- '입사일자'가 0월 0일 이후인 사원이 관리하는 '고객번호'를 찾고자 할 때
  - 입사일자가 0월 0일 이후인 사원의 사원번호를 찾는 것이 Outer loop이고
  - 고객의 관리사원번호가 해당 사원번호와 일치하는지를 찾는 것이 Ineer Loop이다.
- Outer쪽 테이블은 사이즈가 크지 않다면 인덱스를 이용하지 않을 수 있다.
  - Table Full Scan을 하더라도 한번에 그치기 때문
- 하지만 Inner쪽 테이블은 무조건 인덱스를 사용하여야 한다.

4.1.2 NL 조인 실행계획 제어
- select /*+ ordered use_nl(컬럼B) use_nl (컬럼C) use_hash(컬럼D)*/ *
  - B를 Inner Loop로 A와 조인하고, C와 조인할때도 NL로 조인하고, D와 조인할때는 해시방식을 이용한 것이다.
-  select /* use_nl(A,B,C,D) */ /일 경우 옵티마이저에게 실행계획을 맡긴다.

4.1.3 NL 조인 수행 과정 분석
- 각단계를 마무리하고 다음 단계로 넘어가는 것이 아닌 한 레코드씩 순차적으로 진행됨

-264p

4.1.4 NL 조인 튜닝 포인트
- NL조인의 절대일량은 첫 처리결과에 따라 달렸다.(첫 인덱스를 읽고난 후)
  - 처음 걸리는 조건의 양만큼 뒤의 조건들을 테이블 풀 스캔 해야하기 때문
- 일반적으로는
  - NL조인에서 과도한 랜덤 액세스가 발생하는 지점을 파악하고
  - 조인순서를 변경하거나 인덱스를 추가, 변경해서 랜덤액세스의 양을 줄일 수 있는지 검토한다.
  - 이와 같은 방식들이 충분하지 않을 때 소트머지조인, 해시조인을 검토
 
4.1.5 NL조인의 특징
- 랜덤 액세스 위주의 조인
  - 인덱스가 아무리 완벽해도 대량 데이터를 조인 시 불리하다.
- 한 레코드씩 순차적으로 진행
  - 대량 데이터 처리 시 매우 치명적으로 불리하지만
  - 아무리 큰 테이블을 조인하더라도 응답속도가 매우 빠르다는 장점을 가진다.(부분범위 처리)
- 다른 조인방식과 비교했을 때 인덱스 구성전략이 매우 중요하다.
- 위와 같은 특징들 때문에 소량데이터 및 부분범위 처리에 특화된 OLTP 시스템에 적합하다.

4.1.6 NL 조인 튜닝 실습
- 

4.1.7 NL조인 확장 메커니즘
- 테이블 Prefetch, 배치IO기능 : 내부 실행계획까진 몰라도 되지만 실행계획에 표시되는 형태는 알아둘 필요가 있다.
  - Inner쪽 테이블(ex:고객 테이블에 대한 테이블 액세스)에 대한 연산이 맨 위(prefetch)나 맨 아래(batch IO)로 옮겨진다.
- 테이블 Prefetch기능 : 인덱스를 이용해 테이블을 액세스하다가 IO가 생기면 다음에 읽게 될 블록까지 처리
- 배치IO기능 : IO를 미루다가 일정량이 쌓이면 한꺼번에 처리
  - 배치IO는 정렬순서가 보장되지 않을 수 있다.
  - 따라서 11g부터는 no_nlj_batching(b)와 같은 힌트를 추가하거나 order by를 명시하여야 한다.
 
4.2 소트 머지 조인
- 조인 컬럼에 인덱스가 없거나, 대량 데이터 조인이라 인덱스가 효과적이지 않을 때 NL조인 대신 소트 머지 조인, 해시 조인 사용

4.2.1 SGA vs. PGA
- SGA system global area
  - 여러 프로세스가 공유하지만 동시 액세스는 불가능
  - 동시 액세스 시도를 직렬화하는 Lock 매커니즘으로 래치Latch 존재
  - 블록을 읽으려고 할 시 버퍼 Lock도 획득해야함
- PGA
  - 오라클이 갖는 독립적인 메모리 영역(다른 프로세스와 공유 X)
  - PGA영역이 부족할 시 Temp 테이블 스페이스 사용
  - 래치 매커니즘 불필요. SGA 버퍼캐시보다 훨씬 빠름
 
4.2.2 기본 메커니즘 - 이름과 동일한 순서를 가진다.
1) 소트 단계 : 양쪽 집합을 조인 컬럼 기준으로 정렬한다.
2) 머지 단계 : 정렬한 양쪽 집합을 서로 머지한다.

4.2.3 소트 머지 조인이 빠른 이유
- 4.2.2의 1단계에서 정렬된 집합은 PGA영역과 초과되는 부분은 Temp Table Space에 저장된다.(정렬된 상태로)
  - PGA에 정렬된 데이터를 이용해서 조인하기 때문에 인덱스가 없어도 빠르게 조인할 수 있다.
- NL조인의 최대단점은 대량 데이터 조인에 성능이 매우 느리다.
  - → 소트 머지 조인, 해시조인이 개발된 이유
  - NL조인은 인덱스든 테이블이든 모든 블록에 대해 래치 획득 및 캐시버퍼 체인 스캔 과정을 거친다.
    - 버퍼캐시에서 찾지 못한 블록은 무조건 디스크를 물리적으로 읽어야 한다. (인덱스 손익분기점의 한계가 고스란히 적용됨)
- 소트 머지 조인도 조인 대상 집합을 읽을 때는 DB버퍼캐시를 경유하고, 인덱스를 이용하기도 한다.

4.2.4 소트 머지 조인의 주 용도
- 해시조인이 소트머지의 역할 대부분을 가져갔지만 해시조인은 조인 조건식이 = 조건이 아닐 경우 사용할 수 없다.
- 따라서 소트 머지 조인은 다음과 같은 상황에 주로 사용된다.
  - 조인 조건식이 = 조건이 아닌 대량 데이터 조인
  - 조인 조건식이 아예 없는 조인(Cross조인, 카테시안 곱)

4.2.5 소트 머지 조인 제어하기
- use_merge(o) 힌트 사용

4.2.6 소트 머지 조인 특징 요약
- 소트 머지 조인은 조인을 위해 실시간으로 인덱스를 생성하는 것과 다를 바 없다.
- 소트 부하만 감수한다면 대량데이터를 조인할 때 건건히 버퍼캐시를 경유하는 NL조인보다 빠르다.
- 인덱스 유무에 대해 NL조인은 영향을 많이 받지만 소트 머지 조인은 받지 않는다.
- 양쪽 테이블을 개별적으로 읽고 조인을 시작한다.

4.3 해시 조인
- 소트 머지 조인과 비슷하게 인덱스를 이용하지 않는 특성을 가진다.
- 소트머지조인의 정렬에 필요한 부담도 없다.

4.3.1 기본 메커니즘
1) Build 단계 : 작은쪽 테이블(Build Input)을 읽어 해시테이블(해시 맵)을 생성한다.
2) Probe 단계 : 큰 쪽 테이블(Probe Input)을 읽어 해시 테이블을 탐색하면서 조인한다.

- /*+ ordered use hash(c) */ from e, c 가 있을 때
- e(Build input)를 해시테이블(해시 맵)화 하여 c(Probe Input)을 이용해 탐색하라는 힌트
- 여기서 조인 조건인 사원번호(c의 관리사원번호)를 사용한다.
- 해시 테이블은 PGA영역의 Hash Area에 저장하고 초과할 시 Temp 테이블 스페이스에 저장한다.
- 해시조인의 Probe 단계는 NL조인과 다르지 않다. (소트 머지조인의 머지단계도 마찬가지)

4.3.2 해시 조인이 빠른 이유
- 소트 머지 조인과 마찬가지로 해시 테이블을(정렬된 테이블을) PGA에 저장하고 이용하기 때문이다.
- Build Input과 Probe Input 각 테이블을 읽을 때는 DB 버퍼캐시를 경유하고, 인덱스를 이용하기도 한다.
- + 해시테이블에는 해시 키를 생성하는 조인 키값만 저장되는 것이 아니라 SQL에 사용된 컬럼을 모두 저장한다.
  - 그렇지 않을 시 다시 ROWID로 테이블 블록을 액세스해야 하는 비용이 들기 때문(장점이 무효화된다.)

- 대량데이터를 조인할 때 일반적으로 소트머지조인보다 해시조인이 빠른 이유는 사전 준비작업의 차이.
  - 소트 머지 조인은 양쪽 집합을 모두 정렬해서 PGA에 담지만 해시 조인은 한쪽(작은쪽, Build Input)만 PGA 및 소트 머지 조인보다 드물게 테이블 스페이스에 저장한다.
  - 해시값이 Temp table space에 담겨도 일반적으로 대용량 데이터 조인에는 가장 빠르다.

4.3.3 대용량 Build Input 처리
- Build Input과 Probe Input이 모두 대용량 테이블이라면 분할 정복방식을 사용한다.
  1) 파티션 단계 : 양쪽 집합의 조인 컬럼에 해시함수를 적용하고 반환된 해시 값에 따라 동적으로 파티셔닝 한다.
    - 독립적으로 처리할 수 있는 여러 작은 서브집합으로 분할하여 파티션 짝 생성
    - 인메모리 해시 조인보다 성능이 많이 떨어진다.
  2) 조인 단계 : 각 파티션 짝에 대해 하나씩 조인을 수행.
    - 각각에 대한 Build Input과 Probe Input은 독립적으로 결정됨
    - 모든 파티션 짝에 대해 처리를 마칠때까지 반복


- 07.31(월) 270p ~ 289p


4.3.4 해시 조인 실행계획 제어
- use_hash(o) 사용
- leading (t1, t2, t3) swap_join_inputs(t3) -> t3를 build input으로 지정
- leading (t1, t2, t3) no_swap_join_inputs(t3) -> t1과 t2가 조인한 결과집합을 build input으로 지정 (t3를 probe input으로 지정)

4.3.5 조인 메소드 선택 기준 
1) 소량 데이터 조인 -> NL조인
2) 대량 데이터 조인 -> 해시조인
3) 대량 데이터 조인인데 해시조인이 불가능할 때(조인 조건식이 =조건이 아닐 때) -> 소트 머지 조인
  - 대소량의 기준 : NL조인 기준으로 최적화하여도 랜덤액세스가 많아서 성능이 부족한 경우 -> 대량

- 수행 빈도가 높을 경우 다음과 같은 기준도 고려
  1) NL조인과 해시조인의 성능이 같다면 -> NL조인
  2) 해시 조인이 약간 더 빨라도 -> NL조인
  3) NL조인보다 해시 조인이 훨씬 빠른 경우 -> 해시 조인

- 해시조인이 주로 사용되는 경우의 특징
  - 수행빈도가 낮고, 쿼리 수행 시간이 오래 걸리고, 대량 데이터 조인이 요구될 때
  - 이는 DW, 배치 프로그램, OLAP 쿼리의 특징이다.
- 해시 조인은 메모리와 CPU사용률을 크게 높인다. 해시 맵 생성에 래치 경합도 발생한다.


4.4 서브쿼리 조인
- 여러개의 서브쿼리가 조인하는 복잡한 경우 옵티마이저가 어떻게 처리하는지 이해하자
- 서브쿼리 변환

4.4.1 서브쿼리 변환이 필요한 이유
- 서브쿼리 변환 : 옵티마이저가 SQL을 의미적으로 동일하면서도 더 나은 성능이 기대되는 형태로 재작성하는 것
- 서브쿼리의 종류
  - 스칼라 서브쿼리 : 정확히 하나의 값만 반환. 컬럼이 위치할 수 있는 거의 모든 곳에 사용 가능
  - 인라인 뷰 (from 절에 사용)
  - 중첩된 서브쿼리 (where 절에 사용)
    - 메인쿼리의 컬럼을 창조하는 중첩된 서브쿼리를 '상관관계 서브쿼리'라 한다.

4.4.2 서브쿼리와 조인
- 서브쿼리는 메인쿼리의 건수만큼 종속되어 반복적으로 필터링하는 방식으로 실행된다.

- 필터 오퍼레이션
  - no_unnest 힌트로 유도한다. (서브쿼리를 풀지 말라 지시)
  - NL조인과 처리루틴이 같으나 다음과 같은 차이점 존재
    1) 메인쿼리의 한 로우가 서브쿼리의 한 로우와 조인에 성공하는 순간 멈추고 메인 쿼리의 다음 로우를 처리한다.
    2) 필터는 캐싱기능을 갖는다 : 서브쿼리의 입력값에 따른 반환 값(true/false)를 캐싱하여 반복된 값에 대한 작동여부를 판단
    3) NL조인과 달리 조인순서가 고정되며 메인쿼리가 항상 드라이빙 집합

- 서브쿼리 unnesting (서브쿼리 Flattening)
  - 서브쿼리를 풀어내어 종속성을 없앰으로써 filter방식이 아닌 다양한 최적화 기법을 적용 가능
  - nl 세미조인 : nl조인과 루틴이 같지만 조인에 성공할 시 메인쿼리의 다음 로우를 계속 처리한다(필터 오퍼레이션의 기능)
  - nl세미조인과 필터 오퍼레이션의 차이는 드라이빙 집합이 바뀔 수 있다는 것(서브쿼리도 드라이빙 집합이 될 수 있다.)
  - 다만 이때는 sort unique 오퍼레이션이 발동해서 레코드 중복을 예방한다.
  - + rownum 조건은 서브쿼리의 unnesting을 막는다.(서브쿼리에 사용할 때 주의하여야 한다.)
   
- 서브쿼리 pushing
  - unnesting되지 않은 서브쿼리는 항상 필터방식으로 처리되고, 실행계획의 맨 마지막에서 처리된다.
  - push_subq 힌트로 서브쿼리 필터링을 가능한 한 앞에서 처리하게 강제할 수 있다.
  - push_subq는 unnesting되지 않은(서브쿼리를 풀지 않은)경우에만 작동한다. 따라서 no_unnest 힌트와 같이 사용한다.
 
4.4.3 뷰View와 조인
- 최적화 단위는 쿼리 블록
  - 옵티마이저가 뷰 쿼리를 변환하지 않으면 뷰 쿼리 블록을 독립적으로 최적화
  - 따라서 뷰 바깥의 조건에 의해 걸러져야할 데이터를 뷰 안에서는 다 읽을 수도 있음
  - 이럴 때 뷰와 메인 쿼리의 머지를 위해 merge 힌트를 사용
    
  - 이 결과로 group by 조건이 사용될 시 부분범위 처리는 불가능해지기 때문에 데이터가 대량이라면 NL조인보다는 해시 조인이 성능이 좋다.

- 조인 조건 pushdown
  - 메인쿼리의 조인 조건절 값을 뷰 안으로 밀어 넣는 기능 ( push_pred 힌트 )
  - 부분범위 처리 가능, group by 도중에 중단 가능
  - merge 힌트와 같이 작동하지 않기 때문에 no_merge 기술 필요
 
- + Lateral 인라인 뷰
  - 인라인 뷰에 LATERAL 문구를 기술하면 인라인 뷰에서 메인쿼리 테이블의 컬럼을 참조 가능 (12c 이후)
- Outer Apply, Cross Apply : 조인 조건 push down 기능이 작동하지 않을 경우 고려 가능


- 08.01(화) 290p ~ p316p


